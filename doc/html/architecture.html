<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
 
 <title>papy - Google Code</title>
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 
 <link rel="shortcut icon" href="http://www.gstatic.com/codesite/ph/images/defaultlogo.png"/>
 <link type="text/css" rel="stylesheet"
       href="./_static/custom.css" />
 <link type="text/css" rel="stylesheet"
       href="http://www.gstatic.com/codesite/ph/3770121226765569314/css/ph_core.css" />
 <link type="text/css" rel="stylesheet"
       href="http://www.gstatic.com/codesite/ph/3770121226765569314/css/ph_detail.css" />
 <link rel="stylesheet"  type="text/css"
       href="./_static/pygments.css" /> 
 
 <link type="application/atom+xml" rel="alternate"
 href="/feeds/p/papy/svnchanges/basic?path=/wiki/" />
 
 
<!--[if IE]>
 <link type="text/css" rel="stylesheet"
       href="http://code.google.com/hosting/css/d_ie.css" />
<![endif]-->

<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '',
          VERSION:     '1.0b1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="./_static/jquery.js"></script>
    <script type="text/javascript" src="./_static/interface.js"></script>
    <script type="text/javascript" src="./_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="contents.html" />
    <link rel="index" title="Global index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="PaPy v1.0b1 documentation" href="index.html" />
    <link rel="next" title="The most barebones parallel pipeline" href="barebones.html" />
    <link rel="prev" title="Introduction" href="introduction.html" />
</head>
<body class="t6">
 <div id=gaia>
  <font size="-1">
 
 <a href="http://code.google.com/p/support/wiki/WhatsNew" style="color:#a03">What's new?</a>
 | <a href="http://code.google.com/p/support/">Help</a>
 
 </font> 

 </div>
 <table style="padding:0px; margin: 0px 0px -6px 0; width:100%" cellpadding=0 cellspacing=0>
 <tr>
 <td><a href="/"><img src="http://www.gstatic.com/codesite/ph/images/defaultlogo.png" alt=papy/></a></td>
 <td>
 
 <div id="pname">
 <a href="http://code.google.com/p/papy/" style="text-decoration:none; color:#000">papy</a>
 
 </div>
 <div id="psum">
 <i><a href="http://code.google.com/p/papy/" style="text-decoration:none; color:#000">PaPy v1.0b1 documentation</a></i>
 </div>
 
 </td>
 <td style="white-space:nowrap; text-align:right">
 
 <form action="http://code.google.com/hosting/search">
 <input size=30 name=q value=""/>
 <input type=submit name=projectsearch value="Search Projects" />
 <input type=submit name=websearch value="Search the Web" />
 </form>
 
 </tr>
 </table>


<table id="mt" cellspacing="0" cellpadding="0" width="100%" border="0">
 <tr>
 <th onclick="if (!cancelBubble) _go('http://code.google.com/p/papy/');">
 <div class="tab inactive">
 <div class="round4"></div>
 <div class="round2"></div>
 <div class="round1"></div>
 <div class="box-inner">
 <a onclick="cancelBubble=true;" href="http://code.google.com/p/papy/">Project&nbsp;Home</a>
 </div>
 </div>
 </th><td>&nbsp;&nbsp;</td>
 
 
 
 
 <th onclick="if (!cancelBubble) _go('http://code.google.com/p/papy/downloads/list');">
 <div class="tab inactive">
 <div class="round4"></div>
 <div class="round2"></div>
 <div class="round1"></div>
 <div class="box-inner">
 <a onclick="cancelBubble=true;" href="http://code.google.com/p/papy/downloads/list">Downloads</a>
 </div>
 </div>
 </th><td>&nbsp;&nbsp;</td>
 
 
 
 
 
 <th onclick="if (!cancelBubble) _go('http://code.google.com/p/papy/w/list');">
 <div class="tab inactive">
 <div class="round4"></div>
 <div class="round2"></div>
 <div class="round1"></div>
 <div class="box-inner">
 <a onclick="cancelBubble=true;" href="http://code.google.com/p/papy/w/list">Wiki</a>
 </div>
 </div>
 </th><td>&nbsp;&nbsp;</td>
 
 
 
 
 
 
 
 <th onclick="if (!cancelBubble) _go('http://code.google.com/p/papy/issues/list');">
 <div class="tab inactive">
 <div class="round4"></div>
 <div class="round2"></div>
 <div class="round1"></div>
 <div class="box-inner">
 <a onclick="cancelBubble=true;" href="http://code.google.com/p/papy/issues/list">Issues</a>
 </div>
 </div>
 </th><td>&nbsp;&nbsp;</td>
 
 
 
 
 
 
 <th onclick="if (!cancelBubble) _go('http://code.google.com/p/papy/source/list');">
 <div class="tab inactive">
 <div class="round4"></div>
 <div class="round2"></div>
 <div class="round1"></div>
 <div class="box-inner">
 <a onclick="cancelBubble=true;" href="http://code.google.com/p/papy/source/list">Source</a>
 </div>
 </div>
 </th><td>&nbsp;&nbsp;</td>
 
 
 
 <td width="100%">&nbsp;</td>
 </tr>
</table>
<table cellspacing="0" cellpadding="0" width="100%" align="center" border="0" class="st">
 <tr>
 
 
 
 <td>
 <div class="issueList">
<div class=isf>
 
 
 
 <a href="index.html">PaPy v1.0b1 documentation</a> |
 <span>
   <a href="genindex.html" title="General Index"
      accesskey="I">index</a>
 </span> |
 <span>
   <a href="modindex.html" title="Global Module Index"
      accesskey="M">modules</a>
 </span> |
 <span>
   <a href="barebones.html" title="The most barebones parallel pipeline"
      accesskey="N">next</a>
 </span> |
 <span>
   <a href="introduction.html" title="Introduction"
      accesskey="P">previous</a>
 </span> |
 <span class="inIssueList">
   <span>Search</span>
    <form action="search.html" method="GET" style="display:inline">
      <input size=30 name=q value=""/>
      <input type=submit name=projectsearch value="Search Documentation" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
 </span>

</div>
</div>

 </td>
 
 
 
 
 
 
 
 
 <td height=4 align=right valign=top class="bevel-right">
 <div class="round4"></div>
 <div class="round2"></div>
 <div class="round1"></div>
 </td>
 </tr>
</table>
<script>
 var cancelBubble = false;
 function _go(url) { document.location = url; }
</script>

<div id="maincol">
<!-- IE -->



<style>
 #downloadbox { 
 padding: 6px; 
 overflow: hidden;
 white-space: nowrap;
 text-overflow: ellipsis;
 }
 #downloadbox a {
 margin: 0 0 0 0;
 display: block;
 padding-left: 0px;
 }
 #owners a, #members a { white-space: nowrap; }
</style>

<div style="float:right; width:25em; margin:0 0 1em 2em">

 
 <div class=pmeta_bubble_bg>
 <div class="round4"></div>
 <div class="round2"></div>

 <div class="round1"></div>
 <div class="box-inner">
 <table class="pmeta" cellpadding=5>
 <tr><th>Previous:</th>
 <td><ul>
 
 <li>
   <a href="introduction.html" title="previous chapter">Introduction</a>
 </li>
 

 
 </ul></td>
 </tr>
 <tr><th>Next:</th>
 <td><ul>
 
 <li>
   <a href="barebones.html" title="next chapter">The most barebones parallel pipeline</a>
 </li>
 

 
 </ul></td>
 </tr>
 
 
 
 </table>

 </div>
 <div class="round1"></div>
 <div class="round2"></div>
 <div class="round4"></div>
 </div>
 
 
 
 <div style="background:#ddf8cc; margin-bottom: 5px;table-layout:fixed">

 <div class="round4"></div>

 <div class="round2"></div>
 <div class="round1"></div>
 <div class="box-inner">
 <div id=downloadbox>
  <b>Table of Contents</b><br/>
  <table class="pmeta toc" cellpadding=5><tr><td>
	<ul>
<li><a class="reference external" href="">Architecture</a><ul>
<li><a class="reference external" href="#understanding-the-object-oriented-model">Understanding the object-oriented model</a></li>
<li><a class="reference external" href="#the-core-components">The core components</a></li>
<li><a class="reference external" href="#creating-a-pipeline">Creating a pipeline</a></li>
<li><a class="reference external" href="#the-imap">The IMap</a></li>
<li><a class="reference external" href="#the-worker">The Worker</a></li>
<li><a class="reference external" href="#built-in-worker-functions">Built-in worker functions</a></li>
<li><a class="reference external" href="#the-piper">The Piper</a></li>
<li><a class="reference external" href="#the-dagger">The Dagger</a><ul>
<li><a class="reference external" href="#edges-vs-pipes">Edges vs. pipes</a></li>
<li><a class="reference external" href="#working-with-the-dagger">Working with the Dagger</a></li>
<li><a class="reference external" href="#the-dagger-run-time">The Dagger run-time</a></li>
</ul>
</li>
<li><a class="reference external" href="#the-plumber">The Plumber</a></li>
<li><a class="reference external" href="#the-additional-components">The additional components</a></li>
</ul>
</li>
</ul>

  </td></tr></table>

 
 </div>
 </div>
 <div class="round1"></div>
 <div class="round2"></div>
 <div class="round4"></div>
 </div>
 
 


 </div>
</div>

 <div style="padding:0 3em 1.2em 0">
   
     
  <div class="section" id="architecture">
<h1>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h1>
<p>The architecture of <em>PaPy</em> is remarkably simple and intuitive yet flexible. It
consists of only four core components (classes) to construct a data processing
pipeline. Each component provides an isolated subset of the functionality, which
includes: arbitrary directed pipeline topology, parallelism and distributed
computing, user function wrapping, and run-time interactions (e.g. logging).
<em>PaPy</em> is intrinsically modular, any function can be used in several places in a
pipeline or re-used in another pipeline.</p>
<p>In this chapter we first introduce object-otiented programming in the context
of papy, explain briefly the core components (building blocks) and introduce a
conceptual outline of pipeline creation. In later sections we revisit each
component and explain the how and why.</p>
<div class="section" id="understanding-the-object-oriented-model">
<h2>Understanding the object-oriented model<a class="headerlink" href="#understanding-the-object-oriented-model" title="Permalink to this headline">¶</a></h2>
<p>Papy is written in an object-oriented(OO) way. The main components: Plumber,
Dagger, Pipers and Workers are in fact class objects. For the end-user it is
important to distinguish between classes and class instances. In Python both
classes and class instances are objects. When you import the module in your
script:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">papy</span>
</pre></div>
</div>
<p>A new object (a module) will be availble i.e. you will be able to access classes
and functions provided by papy e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">papy</span><span class="o">.</span><span class="n">some_function</span>
<span class="n">papy</span><span class="o">.</span><span class="n">SomeClass</span>
</pre></div>
</div>
<p>The name of the new object will be papy. This object has several attributes
which correspond to the components and interface of papy e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">papy</span><span class="o">.</span><span class="n">Plumber</span>
<span class="n">papy</span><span class="o">.</span><span class="n">Dagger</span>
<span class="n">papy</span><span class="o">.</span><span class="n">Piper</span>
<span class="n">papy</span><span class="o">.</span><span class="n">Worker</span>
</pre></div>
</div>
<p>Attributes are accessed in python using the object.attribute notation. These
components are classes not class instances. They are used to construct class
instances which correspond to the run-time of the program. A single class can in
general have multiple instances. A class instance is constructed by &#8220;calling&#8221;
(in fact initializing) the class.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">class_instance</span> <span class="o">=</span> <span class="n">Class</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<p>The important part is that using papy involves constructing many classes.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">worker_instance</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">(</span><span class="n">custom_function</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">argument</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="n">piper_instance</span> <span class="o">=</span> <span class="n">Piper</span><span class="p">(</span><span class="n">worker_instance</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="n">your_interface</span> <span class="o">=</span> <span class="n">Plumber</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-core-components">
<h2>The core components<a class="headerlink" href="#the-core-components" title="Permalink to this headline">¶</a></h2>
<p>The core components form the end-user interface i.e. the classes which the user
is expected use directly.</p>
<blockquote>
<ul>
<li><dl class="first docutils">
<dt>The IMap - An implementation of an iterated map function which can &#8216;process&#8217;</dt>
<dd><p class="first last">multiple tasks (function-sequence tuples) in parallel using
either threads or processes on the local machine or on remote
RPyC servers.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The Pipers(Workers) - combined provide the functionality by wrapping</dt>
<dd><p class="first last">user-defined functions handling exceptions and
reporting.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The Dagger - defines the topology of the pipeline in the form of a directed</dt>
<dd><p class="first last">acyclic graph i.e. the connectivity of the flow (pipes).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The Plumber - provides the interface to set-up run and monitor a pipeline</dt>
<dd><p class="first last">(run-time).</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These terms are also covered briefly in the dictionary section.</p>
</div>
</div>
<div class="section" id="creating-a-pipeline">
<h2>Creating a pipeline<a class="headerlink" href="#creating-a-pipeline" title="Permalink to this headline">¶</a></h2>
<p>This documentation is all about creating a valid papy pipeline. In the process
of design we tried to make papy as idiosyncrasy-free as possible, relying on
familiar concepts of map functions and directed acyclic graphs. A pipeline has
two very distinct states <em>before</em> and <em>after</em> it is started. Those states
correspond to the &#8220;creation time&#8221; and &#8220;run-time&#8221;. At creation time functions are
defined (written or imported) and the the data-flow is defined by connecting
functions by directed pipes. At run time data is actually pumped through the
pipeline. This can be summarized by the following outline:</p>
<blockquote>
<ol class="arabic simple">
<li>Write worker functions (the functions in the nodes)</li>
<li>Create Worker instances (specify worker function parameters)</li>
<li>Create Piper instances (specify how/where to evaluate the functions)</li>
<li>Create a Dagger (specify the connections pipeline)</li>
<li>Connect the pipeline to the input</li>
<li>Run the pipeline.</li>
</ol>
</blockquote>
<p>The first 4 steps correspond to the &#8220;creation time&#8221; the last two to the &#8220;run
time&#8221; of the pipeline. A pipeline can be stored and loaded as a python script.
In the following sections the building blocks of a pipeline are explained. Papy
imposes restrictions on the inputs and outputs of a worker function and on
recommends a generic way to construct a pipeline:</p>
<p>input_iterator -&gt; input_piper -&gt; ... processing pipers ... -&gt; output_piper</p>
<p>The output piper should be used to store the output of the pipeline
persistently i.e. it should return None. Papy provides useful functions to
create output pipers.</p>
</div>
<div class="section" id="the-imap">
<h2>The IMap<a class="headerlink" href="#the-imap" title="Permalink to this headline">¶</a></h2>
<p>The IMap class is described extensively in the section about parallelism and in
the API documentation. Here it suffices to say that it is an object which allows
to execute <em>multiple</em> functions using a shared pool of worker processes. This
class is independent of papy (in fact it is a seperate module) and can be used
in any python code as an alternative to multiprocessing.Pool imap, map,
unordered_imap or itertools.imap.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># doc/examples/imap_01.py</span>
</pre></div>
</div>
<p>The next examples illustrates how IMap can be used to share a pool of worker
processes among two tasks.</p>
<blockquote>
# doc/examples/imap_02.py</blockquote>
</div>
<div class="section" id="the-worker">
<h2>The Worker<a class="headerlink" href="#the-worker" title="Permalink to this headline">¶</a></h2>
<p>The Worker is a class which is created with a function or multiple functions
(and the functions arguments) as arguments. It is therefore a function wrapper.
If multiple functions are supplied they are assumed to be nested with the last
function being the outer most i.e.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">h</span><span class="p">)</span> <span class="ow">is</span> <span class="n">h</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">()))</span>
</pre></div>
</div>
<p>If a Worker instance is called this compsite function is evaluated on the
supplied argument.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">papy</span> <span class="kn">import</span> <span class="n">Worker</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">radians</span><span class="p">,</span> <span class="n">degrees</span>
<span class="k">def</span> <span class="nf">papy_radians</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">radians</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">papy_degrees</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">degrees</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
<span class="n">worker_instance</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">((</span><span class="n">papy_radians</span><span class="p">,</span> <span class="n">papy_degrees</span><span class="p">))</span>
<span class="n">worker_instance</span><span class="p">([</span><span class="mf">90.</span><span class="p">])</span>
<span class="mf">90.0</span>
</pre></div>
</div>
<p>In this example we create a composite worker from two functions papy_radians and
papy_degrees. The first function converts degrees to radians the second converts
radians to degrees. Obviously if those two functions are nested their result is
identical to their input. papy_radians is evaluated first and papy_degrees last
so the result is in degrees.</p>
<p>The Worker performs several functions:</p>
<blockquote>
<ul class="simple">
<li>standarizes the inputs and outputs of nodes.</li>
<li>allows to reuse and combine multiple functions into as single node</li>
<li>catches and wraps exceptions raised within functions.</li>
<li>allows functions to be evaluated on remote hosts.</li>
</ul>
</blockquote>
<p>A Worker expects that the wrapped function has a defined input and output. The
input is expected to be boxed in a tuple relative to the output, which should
not be boxed. The worker instance expects [float], but returns just float. Any
function which conforms to this is a valid Worker function. Most built-in
functions need to be wrapped. Please refer to the documentation on how to write
Worker functions.</p>
<p>If an exception is raised within any of the user-supplied functions it is cought
by the Worker, but is <em>not raised</em> instead it is wrapped as a WorkerError
exception and returned i.e.:</p>
<div class="highlight-python"><pre>worker = Worker(sqrt) # the math.sqrt function does not conform.
# raises because exception outside sqrt
worker(10.) # this is not a valid worker input
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/marcin/projects/papy/src/papy/papy.py", line 814, in __call__
    exceptions = [e for e in inbox if isinstance(e, PiperError)]
TypeError: 'float' object is not iterable
# does not raise exception inside sqrt
worker([10.]) # this is a valid worker input
WorkerError(TypeError('a float is required',), &lt;built-in function sqrt&gt;, [10.0])
# the WorkerError is returned not raised.</pre>
</div>
<p>The functionality of a Worker instance is defined by the functions it is
composed of and their arguments. Two workers which are composed of the same
functions <em>and</em> called with the same arguments are functionally identical
and a single worker instance can be used in multiple places of a pipeline or in
other words in multiple pipers.</p>
<p>The functions within a worker instance need not to be evaluated by the same
process as the worker instance itself. This is accomplished by the
open-source RPyC module. A worker knows how to inject its functions into a RPyC
connection object, after this the worker method will run in the local process,
but the functions wrapped functions on the remote host.</p>
<blockquote>
import rpyc # import the RPyC module
from papy import Worker
from papy.workers.maths import pow
power = Worker(pow, (2,)) # power of two
power([2]) # evaluated locally
4
conn = rpyc.classic.connect(&#8220;some_host&#8221;)
power._incject(conn) # replace pow with remot pow
power([3]) # evaluated remotely
9</blockquote>
<p>A function can run on the remote host i.e. remote python process/thread only if
the modules on which this function depends are availble on that host and those
modules are imported. IMap provides means to attach import statements to
function definitions using the imports decorator. In this way code sent to the
remote host will work if the imported module is availble remotely.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@imports</span><span class="p">([[</span><span class="s">&#39;re&#39;</span><span class="p">,</span> <span class="p">[]]])</span>
<span class="k">def</span> <span class="nf">match_string</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
    <span class="n">unboxed</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">unboxed</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example shows a valid worker function with the equivalent of the
import statment attached.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>
</pre></div>
</div>
<p>The re module will be availble remotely in the namespace of this
function i.e. other injected functions might not have access to re.</p>
</div>
<div class="section" id="built-in-worker-functions">
<h2>Built-in worker functions<a class="headerlink" href="#built-in-worker-functions" title="Permalink to this headline">¶</a></h2>
<p>Several classes of worker functions are already part of papy. This collection is
expected to grow, currently the following types of workers are included.</p>
<blockquote>
<ul class="simple">
<li>core - basic data-flow</li>
<li>maths - functions on numbers</li>
<li>bool - boolean algebra</li>
<li>io - serialisation, printing and file operations</li>
</ul>
</blockquote>
<p>The core modules includes the family of passer functions. They do not alter the
incoming data, but are used to pass only streams from certain imput pipes. For
example a piper connected to 3 other pipers might propagate input from only one.</p>
<blockquote>
<ul class="simple">
<li>ipasser - propagates the i&#8217;th input pipe</li>
<li>npasser - propagates the n-first input pipes</li>
<li>spasser - propagetes the pipes with numbers in s</li>
</ul>
</blockquote>
<p>For example:</p>
<div class="highlight-python"><pre>from papy.workers.core import *
worker = Worker(ipasser, (0,)) # passes only the first pipe
worker = Worker(ipasser, (1,)) # passes only the second pipe
worker = Worker(npasser, (2,)) # passes the first two pipes
worker = Worker(spasser, ((0,1),) # passes pipes 0 and 1
worker = Worker(spasser, ((1,0),) # passes pipes 1 and 0</pre>
</div>
<p>The output of the passes is a <em>single</em> tuple of the passed pipes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">input0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">,</span><span class="mf">4</span><span class="p">,</span><span class="mf">5</span><span class="p">]</span>
<span class="n">input1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">6</span><span class="p">,</span><span class="mf">7</span><span class="p">,</span><span class="mf">8</span><span class="p">,</span><span class="mf">9</span><span class="p">,</span><span class="mf">10</span><span class="p">,</span><span class="mf">11</span><span class="p">]</span>

<span class="n">worker</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">(</span><span class="n">spasser</span><span class="p">,</span> <span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">))</span>
<span class="c"># will produce output</span>
<span class="p">[(</span><span class="mf">6</span><span class="p">,</span><span class="mf">0</span><span class="p">),</span> <span class="p">(</span><span class="mf">7</span><span class="p">,</span><span class="mf">1</span><span class="p">),</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>The io sub-module contains functions dealing with input/output relations i.e.
data storage and serialization. It currently supports serialization using the
pickle and JSON protocols and file-based data storage. Generic data-base
backends will be added in future.</p>
<p>Data serialization is a way to conver objects (and in Python almost everything
is an object) into a sequence, which can be stored or transmitted. Papy uses the
pickle serialization format to transmit data between local processes and brine
(an internal serialization protocol from RPyC) to transmit data between hosts.</p>
<p>The user might however want to save and load</p>
<dl class="docutils">
<dt>Example::</dt>
<dd># PH</dd>
</dl>
</div>
<div class="section" id="the-piper">
<h2>The Piper<a class="headerlink" href="#the-piper" title="Permalink to this headline">¶</a></h2>
<p>A Piper class instance represents a node in the directed graph of the pipeline.
It defines what function should at this place be evaluated (via the supplied
Worker instance) and how it should be evaluated (via the optional IMap
instance). Besides that it has performs additional functions which include:</p>
<blockquote>
<ul class="simple">
<li>logging and reporting</li>
<li>exception handling</li>
<li>timeouts</li>
<li>input sorting</li>
<li>produce/spawn/consume schemes</li>
</ul>
</blockquote>
<p>To use a piper outside a pipeline three steps are required:</p>
<blockquote>
<ul class="simple">
<li>creation - requires a worker instance, optional arguments e.g. an IMap
instance.</li>
<li>connection - connects the piper to the input</li>
<li>start - starts the calculation (starts the IMap)</li>
</ul>
</blockquote>
<p>In the first step we define the worker which will be evaluated by the piper and
the means to do this computation (a custom IMap instance or the standard
itertools.imap function). Optional arguments are thoroughly explained in the
automatic documentation.</p>
<p>Papy has been designed to log it&#8217;s execution at multiple levels. The IMap
function which should at this stage be bug free logs only debug statments.
Exceptions within worker functions are wrapped as WorkerError exceptions, these
errors are logged by the Piper instance, which called this worker (remember a
single worker instance can be called by multiple pipers). By default the
pipeline is robust to WorkerErrors and these exceptions are logged, but they do
not stop the flow. In this mode if the called Worker instance returnes a
WorkerError the calling Piper instance wraps this error as a PiperError and
returns it down-stream in the pipeline. On the other end if a Worker receives a
PiperError as input it just propagates it further down-stream i.e. it does not
try meaningless calculations on exceptions. In this way errors in the pipeline
propagate down-stream as place-holder PiperErrors.</p>
<p>A Piper instance evaluates the Worker either by the supplied IMap instance
(described elswhere) or by the builtin itertools.imap function (default). In
reality after a piper is connected to the input it creates a task i.e. function,
data, arguments tuples which is added to the IMap instance used to call the imap
function.</p>
<p>IMap instances support timeouts via the optional timeout argument supplied to the
next method. If the IMap is not able to return a result within the specified
time it raises a TimeoutError. This exception is cought by the piper instance
which expects the result, wrapped into a PiperError exception and propagated
down-stream exactly like WorkerErrors. If the piper is used within a pipeline
and a timeout argument given the skipping argument should be set to true
otherwise the number of results from a piper will be bigger then the number of
tasklets, which will hang the pipeline.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># valid with or without timeouts</span>
<span class="n">universal_piper</span> <span class="o">=</span> <span class="n">Piper</span><span class="p">(</span><span class="n">worker_instance</span><span class="p">,</span> <span class="n">parallel</span> <span class="o">=</span><span class="n">imap_instance</span><span class="p">,</span> <span class="n">skipping</span> <span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># valid only with timeouts</span>
<span class="n">nontimeout_piper</span> <span class="o">=</span> <span class="n">Piper</span><span class="p">(</span><span class="n">worker_instance</span><span class="p">,</span> <span class="n">parallel</span> <span class="o">=</span><span class="n">imap_instance</span><span class="p">,</span> <span class="n">skipping</span> <span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the timeouts specified here are &#8216;computation time&#8217; timeouts. If for
example a worker function waits for a server response and the server response
does not arrive within some timeout (which can be an argument for the Worker)
then if this exception is raise within the function it will be wrapped into a
WorkerError and raturned not raised as TimeoutErrors.</p>
<p>A single Piper instance can only be used once within a pipeline (this is unlike
Worker instances).</p>
<p>Pipers are created first and connected to the input data later. The latter is
accomplished by the connect method.</p>
<blockquote>
piper_instance.connect(input_data)</blockquote>
<p>If the piper is used within a papy pipeline i.e. a Dagger or Plumber instance
the user does not have to care about connecting individual pipers. After a piper
has be either started or disconnected, obviously a piper can only be started if
it has been connected before.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">piper_instance</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
<span class="n">piper_instance</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
<span class="c"># or</span>
<span class="n">piper_instance</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>After starting a piper tasks are submitted to the thread/process workers in
the IMap instance and they are evaluated. This is a process which continues
until either the buffer is filled or the input is consumed. Therefore a piper
cannot be simply disconnected when it is &#8216;running&#8217;. A special method is needed
to tell the IMap instance to stop input consumption. Because IMap instances
are shared among pipers such a stop can only occur at stride boundaries. The
piper stop method will eventually stop the IMap instance and put the piper in a
stopped state which allows the piper to be disconnected.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">piper_instance</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">piper_instance</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="n">piper_instance</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span> <span class="c"># can be connected and started</span>
</pre></div>
</div>
<p>Because the stop happens at stride boundary data is not lost during a stop. This
can be illustraded as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#           plus2            plus1</span>
<span class="c"># [1,2,3,4] -----&gt; [3,4,5,6] -----&gt; [4,5,6,7]</span>
<span class="c"># which is equivalent to the following:</span>
<span class="c"># plus1(plus2([1,2,3,4])</span>
</pre></div>
</div>
<p>If the pipers plus2 and plus1 share a single IMap and the stride is two then the
order of evaluation can be (if the results are retrieved):</p>
<div class="highlight-python"><pre>temp1 = plus2(1)
temp2 = plus2(2)
plus1(temp1)
plus1(temp2)
&lt;&lt;return&gt;&gt;
&lt;&lt;return&gt;&gt;
temp1 = plus2(3)
temp2 = plus2(4)
plus1(temp1)
plus1(temp2)
&lt;&lt;return&gt;&gt;
&lt;&lt;return&gt;&gt;</pre>
</div>
<p>Now let&#8217;s assume the the stop method has been called just after plus2(1). We do
not want to loose the temp1 result (as 1 has been already consumed from the
input iterator and iterators cannot rewind), but we can achieve this only if
plus1(temp1) is evaluated this in turn (due to the order of tasklet submission)
can happen only after plus2(2) has been evaluated (i.e. 2 consumed from the
input iterator). To not loose temp2 plus1(temp2) has to be evaluated and finally
the evaluation can stop.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">temp1</span> <span class="o">=</span> <span class="n">plus2</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="n">temp2</span> <span class="o">=</span> <span class="n">plus2</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="n">plus1</span><span class="p">(</span><span class="n">temp1</span><span class="p">)</span>
<span class="n">plus1</span><span class="p">(</span><span class="n">temp2</span><span class="p">)</span>
<span class="p">(</span><span class="n">stopped</span><span class="p">)</span>
</pre></div>
</div>
<p>After the stop method returns all worker processes/threads and helper threads
return and the user can close the python interpreter. It is <em>very</em> important to
realise what happens with the two calculated results. As has been already
mentioned a proper papy pipeline should have an output piper i.e. a piper which
persistently stores the result.</p>
</div>
<div class="section" id="the-dagger">
<h2>The Dagger<a class="headerlink" href="#the-dagger" title="Permalink to this headline">¶</a></h2>
<p>The Dagger is an object to connect Piper instances into a directed acyclic
graph (DAG). It inherits most methods of the Graph object, which is a concise
implementation of the Graph data-structure. The Graph instance is a
dictionary of arbitary hashable objects &#8220;real nodes&#8221;. For example a Piper instance)
connected instances of the Node class &#8220;topological nodes&#8221;. A Node instance is a
also dictionary of &#8220;real nodes&#8221; and their corresponding &#8220;topological nodes&#8221;. A
&#8220;real node&#8221; is in this dictionary if it has an incoming edges from the &#8220;real
node&#8221; in the Graph. A &#8220;topological node&#8221; is therefore a sub-graph of the Graph
object around a hashable object and the whole Graph is a recursively nested
dictionary. The Dagger is designed to store Piper instances as &#8220;real nodes&#8221;,
whereas the Graph makes no assumptions about the object type.</p>
<div class="section" id="edges-vs-pipes">
<h3>Edges vs. pipes<a class="headerlink" href="#edges-vs-pipes" title="Permalink to this headline">¶</a></h3>
<p>A piper instance is created by specifiying a worker (and optionally IMap
instance) and connected to an input. A single input might be consumed by several
pipers. Also the output of a single piper might be an input to several others.
If several down-stream pipers are connected to a single up-stream piper it&#8217;s
output is &#8216;tee&#8217;d&#8217; this means that each downstream piper creates it&#8217;s own virtual
copy of the input iterator. As a result of the above it is much more natural to
think of thos connections as down-stream pipers connected to their input which
implies that the edge direction in the DAG is down-stream &#8211;&gt; up-stream. This
direction is opposite to the direction of the data flow which is up-stream &#8211;&gt;
down-stream. The Dagger class introduces the concept of pipes to ease the
understanding of papy and make mistakes less common. A pipe is nothing else then
a reversed edge. To make this explicit:</p>
<div class="highlight-python"><pre>input -&gt; piper0 -&gt; piper1 -&gt; output # -&gt; represents a pipe
input &lt;- piper0 &lt;- piper1 &lt;- output # &lt;- represents an edge</pre>
</div>
<p>The data is stored internally as edges, but the interface expects pipes. Method
names are explicit.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dagger_instance</span><span class="o">.</span><span class="n">add_edge</span><span class="p">()</span> <span class="c"># (inherited from Graph) expects and edge as input</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">add_pipe</span><span class="p">()</span> <span class="c"># expecs a pipe as input</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although all Graph methods are availble from the Dagger the end-user should
rely on Dagger specific methods only. For example the Graph method add_edge
will allow to add any edge to the instance, whereas add_pipe will not allow
to introduce cycles.</p>
</div>
</div>
<div class="section" id="working-with-the-dagger">
<h3>Working with the Dagger<a class="headerlink" href="#working-with-the-dagger" title="Permalink to this headline">¶</a></h3>
<p>Creation of the a Dagger instance is very easy. An empty Dagger instance is
created without any arguments to the constructor.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dagger_instance</span> <span class="o">=</span> <span class="n">Dagger</span><span class="p">()</span>
</pre></div>
</div>
<p>Optionally a set of pipers and pipes can be specified:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dagger_instance</span> <span class="o">=</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">sequence_of_pipers</span><span class="p">,</span> <span class="n">sequence_of_pipes</span><span class="p">)</span>
<span class="c"># is equivalent to</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">add_pipers</span><span class="p">(</span><span class="n">sequence_of_nodes</span><span class="p">)</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">add_pipes</span><span class="p">(</span><span class="n">sequence_of_pipes</span><span class="p">)</span>
</pre></div>
</div>
<p>The dagger allows to add/delete pipers and pipes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dagger_instance</span><span class="o">.</span><span class="n">add_piper</span><span class="p">(</span><span class="n">piper</span><span class="p">)</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">del_piper</span><span class="p">(</span><span class="n">piper</span> <span class="ow">or</span> <span class="n">piper_id</span><span class="p">)</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">add_pipers</span><span class="p">(</span><span class="n">pipers</span><span class="p">)</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">del_pipers</span><span class="p">(</span><span class="n">pipers</span> <span class="ow">or</span> <span class="n">piper_ids</span><span class="p">)</span>
</pre></div>
</div>
<p>The piper_id is the run-time specific id associated with a given piper instance.
It can be obtained by calling the built-in function id:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">id</span><span class="p">(</span><span class="n">piper</span><span class="p">)</span>
</pre></div>
</div>
<p>This number is also shown when a piper instance is printed.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">piper_instance</span>
</pre></div>
</div>
<p>or represented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">repr</span><span class="p">(</span><span class="n">piper_instance</span><span class="p">)</span>
</pre></div>
</div>
<p>The representation of a Dagger instance also shows the id of the pipers
which are contained in the pipeline.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="n">dagger_instance</span>
</pre></div>
</div>
<p>The id of a Piper instance is created at run-time (it corresponds to the memory
address of the object) therefore they should not be used in scripts. Further two
objects with non overlapping lifetimes can have the same id.</p>
<p>The resolve method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dagger_instance</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">piper</span> <span class="ow">or</span> <span class="n">piper_id</span><span class="p">)</span>
</pre></div>
</div>
<p>returns a piper instance if the supplied piper or a piper with the supplied id
is contained in the dagger_instance. This method by default raises a DaggerError
if the piper is not found. If the argument forgive is True the method
returns None instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dagger_instance</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">missing_piper</span><span class="p">)</span> <span class="c"># raise DaggerError</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">missing_piper</span><span class="p">,</span> <span class="n">forgive</span> <span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># returns None</span>
</pre></div>
</div>
</div>
<div class="section" id="the-dagger-run-time">
<h3>The Dagger run-time<a class="headerlink" href="#the-dagger-run-time" title="Permalink to this headline">¶</a></h3>
<p>The run-time of a dagger starts when it&#8217;s start method is called, but prior to
that all the Piper instances in the dagger need to be connect to their inputs.
The input or inputs for a given piper are defined by its outgoing edges and
those edges are implicit in the Graph data-structure. Therefore after finishing
adding pipers and pipes the Piper instances need to be cross-connected. This is
accomplished by the connect method, which calls the connect method of the Piper
instances within a Dagger instance. After the pipers have been connected they
can be started. Starting a piper means to start it&#8217;s task evaluation, but
because Piper instances can share an IMap instance the order of connections must
be valid, which means that a piper inscance has to be connected to other
pipers only if all its up-stream pipers have been connected. The dagger can
determine the correct order (which corresponds to the reverse postorder of the
graph) and call the connect methods accordingly. The dagger instance keeps track
of all pipers and connections between them not about the run-time specific data
input data to the pipeline. This means that &#8220;input pipers&#8221; i.e. pipers which
have no incoming pipes (or in other words outgoing edges), are not connected
automatically using the connect method call. If the &#8220;input piper&#8221; is connected
to the input manually before the dagger connect method call the connection <em>is
not</em> overriden.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">input_piper</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">add_pipe</span><span class="p">((</span><span class="n">input_piper</span><span class="p">,</span> <span class="n">output_piper</span><span class="p">))</span>
<span class="n">dagger_instance</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="c"># this results in:</span>
<span class="c">#    output_piper.connect(input_piper)</span>
<span class="c"># input_piper is still connected to input_data</span>
</pre></div>
</div>
<p>!!!TODO!!! update code to allow for disconnects</p>
<p>The start method is similar to the connect method in that it is just a wrapper
call to the start method of the Piper instances in the graph. The order of call
is also the reverse postorder of nodes in the graph. The start method might not
do anything (besides logging it&#8217;s call) for pipers which use the itertools.imap
linear evaluation as only shared IMap instances need to be started.</p>
</div>
</div>
<div class="section" id="the-plumber">
<h2>The Plumber<a class="headerlink" href="#the-plumber" title="Permalink to this headline">¶</a></h2>
<p>The Plumber is an easy to use interface to papy. It inherits from the Dagger
objects and can be used like a Dagger, but the Plumber class adds methods
related to the &#8220;run time&#8221; of a pipeline. It should be emphasized that by using a
Plumber instance a pipeline can run in the background.</p>
<blockquote>
<ol class="arabic simple">
<li>loading/saving a pipeline</li>
<li>starting/stopping a pipeline</li>
</ol>
</blockquote>
</div>
<div class="section" id="the-additional-components">
<h2>The additional components<a class="headerlink" href="#the-additional-components" title="Permalink to this headline">¶</a></h2>
<p>Those classes and functions are used by the core components, but are general and might find
application in your code.</p>
<blockquote>
<ul>
<li><dl class="first docutils">
<dt>Graph(Node) - Two classes which implement a graph data-structure using a recursively</dt>
<dd><p class="first">nested dictionary. This allows for simplicity of algorithms/methods
i.e. there are no edge objects because edges are the keys of the Node
dictionary which in turn is the value in the dictionary for the arbitrary
object in the graph i.e.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">papy</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="n">object1</span> <span class="o">=</span> <span class="s">&#39;1&#39;</span>
<span class="n">object2</span> <span class="o">=</span> <span class="s">&#39;2&#39;</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="n">object1</span><span class="p">,</span> <span class="n">object2</span><span class="p">))</span>
<span class="n">node_for_object1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">object1</span><span class="p">]</span>
<span class="n">node_for_object2</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">object2</span><span class="p">]</span>
</pre></div>
</div>
<p class="last">The Dagger is a Graph object with directed edges and no cycles.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>imports    - a function-wrapper, which allows to inject import statments to</dt>
<dd><p class="first last">a functions local namespace at creation (code execution) e.g. on a
remote python process.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>inject     - injects a function(builtin or user) into a RPyC remote connection</dt>
<dd><p class="first last">namespace.</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
</div>
</div>


   
 
 
 </div>
<div id="footer" dir="ltr">
 
 <div class="text">
 
 &copy;2008 Google -
 <a href="http://code.google.com/">Code Home</a> -
 <a href="http://code.google.com/tos.html">Terms of Service</a> -
 <a href="http://www.google.com/privacy.html">Privacy Policy</a> -
  
 </body>
</html>
